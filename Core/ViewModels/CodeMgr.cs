using System;
using System.Collections.Generic;
using System.Linq;
using System.Text;
using System.Threading.Tasks;
using code_in.Views.MainView.Nodes;
using ICSharpCode.NRefactory.TypeSystem;

namespace code_in.ViewModels
{
    public class CodeMgr
    {
        private code_inMgr      _code_inMgr;
        private Models.CodeData _codeData;

        public CodeMgr(code_inMgr ciMgr)
        {
            _codeData = new Models.CodeData();
            _code_inMgr = ciMgr;
        }
        private ICSharpCode.NRefactory.CSharp.SyntaxTree _parseFile(String filePath)
        {
            System.IO.StreamReader fileStream = new System.IO.StreamReader(filePath);
            return _codeData.Parser.Parse(fileStream);
        }

        private void _generateVisualAST(System.Windows.Controls.Grid mainGrid)
        {
            _generateVisualASTRecur(_codeData.AST, this._code_inMgr._mainView);
        }
        int offsetX = 0;
        int offsetY = 0;

        // (z0rg)TODO: Big refacto
        // - Create Node through mainview
        // - Improve code interface of nodes management
        // - Make this function more generic
        //      - avoid setting the name of each node depending of it's type, almost all nodes have a name
        //      - improve interface to make the parent totally transparent
        //      - ...
        // - Improve design to make the node alignement after the parsing
        void _generateVisualASTRecur(ICSharpCode.NRefactory.CSharp.AstNode node, Views.MainView.IVisualNodeContainer parentContainer)
        {
            Views.MainView.Nodes.BaseNode visualNode = null;
            if (node.Children == null)
                return;
            #region Namespace
            if (node.GetType() == typeof(ICSharpCode.NRefactory.CSharp.NamespaceDeclaration))
            {
                visualNode = new Views.MainView.Nodes.NamespaceNode();
                Views.MainView.Nodes.NamespaceNode namespaceNode = visualNode as Views.MainView.Nodes.NamespaceNode;

                namespaceNode.SetSize(400, 250);
                //namespaceNode.Margin = new System.Windows.Thickness(offsetX, offsetY, 0, 0);
                offsetX += 400;
                if (offsetX > 4000)
                {
                    offsetX = 0;
                    offsetY += 250;
                }
                var tmpNode = (ICSharpCode.NRefactory.CSharp.NamespaceDeclaration)node;
                namespaceNode.SetNodeName(tmpNode.Name);
            }
            #endregion
            #region Class

            if (node.GetType() == typeof(ICSharpCode.NRefactory.CSharp.TypeDeclaration)) // Handles class, struct, enum (see further)
            {
                visualNode = new Views.MainView.Nodes.ClassDeclNode();
                Views.MainView.Nodes.ClassDeclNode classDeclNode = visualNode as Views.MainView.Nodes.ClassDeclNode;
                classDeclNode.SetSize(400, 250);

                //classDeclNode.Margin = new System.Windows.Thickness(offsetX, offsetY, 0, 0);
                offsetX += 400;
                if (offsetX > 4000)
                {
                    offsetX = 0;
                    offsetY += 250;
                }
                var tmpNode = (ICSharpCode.NRefactory.CSharp.TypeDeclaration)node;
                switch (tmpNode.Modifiers.ToString()) // Puts the right scope
                {
                    case "Public":
                        classDeclNode.NodeScope.Scope = Views.MainView.Nodes.Items.ScopeItem.EScope.PUBLIC;
                        break;
                    case "Private":
                        classDeclNode.NodeScope.Scope = Views.MainView.Nodes.Items.ScopeItem.EScope.PUBLIC;
                        break;
                    case "Protected":
                        classDeclNode.NodeScope.Scope = Views.MainView.Nodes.Items.ScopeItem.EScope.PROTECTED;
                        break;
                    default:
                        break;
                }
                classDeclNode.SetNodeName(tmpNode.Name);
            }
            #endregion
            #region Method
            #endregion
            #region Attribute
            #endregion
            if (visualNode != null)
                parentContainer.AddNode(visualNode);
            foreach (var n in node.Children)
                _generateVisualASTRecur(n, (visualNode != null ? visualNode : parentContainer));
        }

        public void LoadFile(String filePath, System.Windows.Controls.Grid mainGrid)
        {
            _codeData.AST = _parseFile(filePath);
            _generateVisualAST(mainGrid);
            // Do node placement:
            // - auto
            // - from file
        }

        public void SaveFile(String filePath)
        {
            System.IO.StreamWriter sw = new System.IO.StreamWriter(filePath);
            String code = "// Generated by Visual Studio's Code_in.";
            sw.WriteLine(code);
            sw.Write(_codeData.AST.ToString());
        }
    }
}
